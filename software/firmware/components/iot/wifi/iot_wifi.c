/*$file${iot::wifi::.::iot_wifi.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: esp32_main.qm
* File:  ${iot::wifi::.::iot_wifi.c}
*
* This code has been generated by QM 4.5.0 (https://www.state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${iot::wifi::.::iot_wifi.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <string.h>
#include "freertos/queue.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "nvs.h"

#include "qpc.h"
#if defined(CONFIG_QPC_QSPY_ENABLE)
#include "qs.h"
#endif /* #if defined(CONFIG_QPC_QSPY_ENABLE) */

#include "priorityList.h"
#include "signalList.h"
#include "project_def.h"
#include "iot_wifi.h"

#define MIN_RSSI                      (-100)
#define MAX_RSSI                      (-55)

#define IOT_WIFI_MAXIMUM_RETRY        (5)

enum wifiSignal {
    IOT_WIFI_TICK_SIG = MAX_SIG,

    WIFI_READY_SIG,                 //WIFI_EVENT_WIFI_READY = 0,           /**< ESP32 WiFi ready */
    SCAN_DONE_SIG,                  //WIFI_EVENT_SCAN_DONE,                /**< ESP32 finish scanning AP */
    STA_START_SIG,                  //WIFI_EVENT_STA_START,                /**< ESP32 station start */
    STA_STOP_SIG,                   //WIFI_EVENT_STA_STOP,                 /**< ESP32 station stop */
    STA_CONNECTED_SIG,              //WIFI_EVENT_STA_CONNECTED,            /**< ESP32 station connected to AP */
    STA_DISCONNECTED_SIG,           //WIFI_EVENT_STA_DISCONNECTED,         /**< ESP32 station disconnected from AP */
    STA_AUTHMODE_CHANGE_SIG,        //WIFI_EVENT_STA_AUTHMODE_CHANGE,      /**< the auth mode of AP connected by ESP32 station changed */

    STA_WPS_ER_SUCCESS_SIG,         //WIFI_EVENT_STA_WPS_ER_SUCCESS,       /**< ESP32 station wps succeeds in enrollee mode */
    STA_WPS_ER_FAILED_SIG,          //WIFI_EVENT_STA_WPS_ER_FAILED,        /**< ESP32 station wps fails in enrollee mode */
    STA_WPS_ER_TIMEOUT_SIG,         //WIFI_EVENT_STA_WPS_ER_TIMEOUT,       /**< ESP32 station wps timeout in enrollee mode */
    STA_WPS_ER_PIN_SIG,             //WIFI_EVENT_STA_WPS_ER_PIN,           /**< ESP32 station wps pin code in enrollee mode */
    STA_WPS_ER_PBC_OVERLAP_SIG,     //WIFI_EVENT_STA_WPS_ER_PBC_OVERLAP,   /**< ESP32 station wps overlap in enrollee mode */

    //WIFI_EVENT_AP_START,                 /**< ESP32 soft-AP start */
    //WIFI_EVENT_AP_STOP,                  /**< ESP32 soft-AP stop */
    //WIFI_EVENT_AP_STACONNECTED,          /**< a station connected to ESP32 soft-AP */
    //WIFI_EVENT_AP_STADISCONNECTED,       /**< a station disconnected from ESP32 soft-AP */
    //WIFI_EVENT_AP_PROBEREQRECVED,        /**< Receive probe request packet in soft-AP interface */

    SCAN_START_SIG,
    STA_CONNECT_SIG,
};

Q_DEFINE_THIS_MODULE("iot_wifi")

static const char * TAG = "iot_wifi";
typedef void (*done_cb)(void);

/*$declare${iot::wifi::wifi} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::wifi::wifi} .......................................................*/
typedef struct {
/* protected: */
    QActive super;

/* private: */
    QTimeEvt tickEvt;
    QEQueue deferQueue;
    QEvt const * deferQSto[2];
    esp_netif_t * sta_netif;
    wifi_config_t wifi_config;
    wifi_ap_record_t ap_info[IOT_WIFI_SCAN_LIST_SIZE];
    uint16_t ap_count;
    done_cb scan_done_cb;
    done_cb connect_done_cb;
    bool auto_connect;
    char * ssid;
    char * password;
    bool bHasIp;
} wifi;

/* private: */
static esp_err_t wifi_nvs_read_credential(wifi * const me);
static esp_err_t wifi_nvs_save_credential(wifi * const me, const char * ssid, const char * password);

/* protected: */
static QState wifi_initial(wifi * const me, QEvt const * const e);
static QState wifi_TOP(wifi * const me, QEvt const * const e);
static QState wifi_INITIALIZING(wifi * const me, QEvt const * const e);
static QState wifi_STARTED(wifi * const me, QEvt const * const e);
static QState wifi_CONNECTED(wifi * const me, QEvt const * const e);
static QState wifi_SCANNING(wifi * const me, QEvt const * const e);
static QState wifi_DISCONNECTED(wifi * const me, QEvt const * const e);
static QState wifi_STARTING(wifi * const me, QEvt const * const e);
/*$enddecl${iot::wifi::wifi} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

static wifi l_wifi;
static QEvt const * l_wifiQSto[64];
/* FreeRTOS stack for AO */
static StackType_t wifiStack[2048];

/*$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 650U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.5.0 or higher required
#endif
/*$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${iot::wifi::AO_iot_wifi} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::wifi::AO_iot_wifi} ................................................*/
QActive * const AO_iot_wifi = &(l_wifi.super);
/*$enddef${iot::wifi::AO_iot_wifi} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${iot::wifi::iot_wifi_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::wifi::iot_wifi_ctor} ..............................................*/
void iot_wifi_ctor(void) {
    wifi *me;
    static uint32_t bInitOnce = 0;

    if(bInitOnce == 0) {
        me = &l_wifi;

        /* Init members */
        me->ap_count = 0;
        memset(me->ap_info, 0, sizeof(me->ap_info));
        me->scan_done_cb = NULL;
        me->auto_connect = true;
        me->ssid = NULL;
        me->password = NULL;
        me->bHasIp = false;

        /* Call constructor */
        QActive_ctor(&me->super, Q_STATE_CAST(&wifi_initial));
        /* Call Timer Constructor */
        QTimeEvt_ctorX(&me->tickEvt, &me->super, IOT_WIFI_TICK_SIG, 0U);
        /* Defer Queue */
        QEQueue_init(&me->deferQueue,
                      me->deferQSto, Q_DIM(me->deferQSto));

        /* Create AO Task */
        QActive_setAttr(AO_iot_wifi, TASK_NAME_ATTR, "iot_wifi");
        bInitOnce = 1;
        QACTIVE_START(
                AO_iot_wifi,                    /* AO to start */
                AO_PRIORITY_WIFI,               /* QP priority of the AO */
                l_wifiQSto,                     /* Event Queue Storage */
                Q_DIM(l_wifiQSto),              /* Lenght of Event Queue */
                wifiStack,                      /* Stack storage */
                sizeof(wifiStack),              /* Size of Stack */
                (QEvt *)0                       /* Not Used */
                );


    }

}
/*$enddef${iot::wifi::iot_wifi_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${iot::wifi::iot_wifi_scan_ap} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::wifi::iot_wifi_scan_ap} ...........................................*/
esp_err_t iot_wifi_scan_ap(void * callback) {
    wifi * me = &l_wifi;

    if(me->scan_done_cb != NULL) {
        /* Scan on-going */
        return ESP_ERR_INVALID_STATE;
    }

    me->scan_done_cb = (done_cb)callback;

    QEvt * pEvt;
    pEvt = Q_NEW(QEvt, SCAN_START_SIG);
    QACTIVE_POST(AO_iot_wifi, pEvt, iot_wifi_scan_ap);

    return ESP_OK;
}
/*$enddef${iot::wifi::iot_wifi_scan_ap} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${iot::wifi::iot_wifi_get_ap_count} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::wifi::iot_wifi_get_ap_count} ......................................*/
uint16_t iot_wifi_get_ap_count(void) {
    wifi * me = &l_wifi;

    return (me->ap_count);

}
/*$enddef${iot::wifi::iot_wifi_get_ap_count} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${iot::wifi::iot_wifi_get_ap_name_len} vvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::wifi::iot_wifi_get_ap_name_len} ...................................*/
size_t iot_wifi_get_ap_name_len(uint16_t id) {
    wifi * me = &l_wifi;

    if(id >= me->ap_count) {
        /* invalid id */
        return 0;
    }

    return (strlen((char *)(me->ap_info[id].ssid)));
}
/*$enddef${iot::wifi::iot_wifi_get_ap_name_len} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${iot::wifi::iot_wifi_get_ap_name} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::wifi::iot_wifi_get_ap_name} .......................................*/
char * iot_wifi_get_ap_name(uint16_t id) {
    wifi * me = &l_wifi;

    if(id >= me->ap_count) {
        /* invalid id */
        return NULL;
    }

    return (char *)(me->ap_info[id].ssid);
}
/*$enddef${iot::wifi::iot_wifi_get_ap_name} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${iot::wifi::iot_wifi_connect} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::wifi::iot_wifi_connect} ...........................................*/
esp_err_t iot_wifi_connect(
    const char * ssid,
    const char * password,
    void * callback)
{
    wifi * me = &l_wifi;
    esp_err_t err = ESP_OK;

    if((NULL == ssid) || (NULL == password)) {
        return ESP_ERR_INVALID_ARG;
    }

    if(callback != NULL) {
        if(me->connect_done_cb != NULL) {
            /* Connect on-going */
            return ESP_ERR_INVALID_STATE;
        }
    }

    err = wifi_nvs_save_credential(me, ssid, password);
    if(ESP_OK != err) {
        return (err);
    }

    /* Disconnect from existing AP */
    /* Underlying state machine handles reconnection */
    QEvt * pEvt = Q_NEW(QEvt, STA_DISCONNECTED_SIG);
    QACTIVE_POST(AO_iot_wifi, pEvt, iot_wifi_connect);

    me->connect_done_cb = callback;

    return (err);
}
/*$enddef${iot::wifi::iot_wifi_connect} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${iot::wifi::iot_wifi_has_ip} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::wifi::iot_wifi_has_ip} ............................................*/
bool iot_wifi_has_ip(void) {
    wifi * me = &l_wifi;

    return(me->bHasIp);
}
/*$enddef${iot::wifi::iot_wifi_has_ip} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${iot::wifi::iot_wifi_get_signal_level} vvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::wifi::iot_wifi_get_signal_level} ..................................*/
uint8_t iot_wifi_get_signal_level(int32_t numLevels) {
    int8_t rssi;
    uint8_t sigLevel = 0;

    if(!iot_wifi_has_ip()) {
        return 0;
    }

    /* Get rssi */
    wifi_ap_record_t ap;
    esp_wifi_sta_get_ap_info(&ap);

    rssi = ap.rssi;

    if (rssi <= MIN_RSSI) {
        sigLevel = 0;
    } else if (rssi >= MAX_RSSI) {
        sigLevel = numLevels - 1;
    } else {
        int32_t inputRange = MAX_RSSI - MIN_RSSI;
        int32_t outputRange_q16 = ((int32_t)(numLevels - 1)) << 16;
        int32_t sigLevel_q16 = ((int32_t)(rssi - MIN_RSSI)) * outputRange_q16 / inputRange;
        sigLevel = (uint8_t)((sigLevel_q16 + 32768) >> 16);
    }

    return sigLevel;
}
/*$enddef${iot::wifi::iot_wifi_get_signal_level} ^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${iot::wifi::wifi_event_handler} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::wifi::wifi_event_handler} .........................................*/
static void wifi_event_handler(
    void * event_handler_arg,
    esp_event_base_t event_base,
    int32_t event_id,
    void * event_data)
{
    wifi * me = &l_wifi;

    QEvt * pEvt;

    if(WIFI_EVENT == event_base) {
        switch(event_id) {
            case WIFI_EVENT_WIFI_READY: {
                ESP_LOGI(TAG, "WIFI_EVENT_WIFI_READY");
                pEvt = Q_NEW(QEvt, WIFI_READY_SIG);
                QACTIVE_POST(AO_iot_wifi, pEvt, wifi_event_handler);
                break;
            }
            case WIFI_EVENT_SCAN_DONE: {
                ESP_LOGI(TAG, "WIFI_EVENT_SCAN_DONE");
                pEvt = Q_NEW(QEvt, SCAN_DONE_SIG);
                QACTIVE_POST(AO_iot_wifi, pEvt, wifi_event_handler);
                break;
            }
            case WIFI_EVENT_STA_START: {
                ESP_LOGI(TAG, "WIFI_EVENT_STA_START");
                pEvt = Q_NEW(QEvt, STA_START_SIG);
                QACTIVE_POST(AO_iot_wifi, pEvt, wifi_event_handler);
                break;
            }
            case WIFI_EVENT_STA_STOP: {
                ESP_LOGI(TAG, "WIFI_EVENT_STA_STOP");
                me->bHasIp = false;
                pEvt = Q_NEW(QEvt, STA_STOP_SIG);
                QACTIVE_POST(AO_iot_wifi, pEvt, wifi_event_handler);
                break;
            }
            case WIFI_EVENT_STA_CONNECTED: {
                ESP_LOGI(TAG, "WIFI_EVENT_STA_CONNECTED");
                pEvt = Q_NEW(QEvt, STA_CONNECTED_SIG);
                QACTIVE_POST(AO_iot_wifi, pEvt, wifi_event_handler);
                break;
            }
            case WIFI_EVENT_STA_DISCONNECTED: {
                ESP_LOGI(TAG, "WIFI_EVENT_STA_DISCONNECTED");
                me->bHasIp = false;
                pEvt = Q_NEW(QEvt, STA_DISCONNECTED_SIG);
                QACTIVE_POST(AO_iot_wifi, pEvt, wifi_event_handler);
                break;
            }
            case WIFI_EVENT_STA_AUTHMODE_CHANGE: {
                ESP_LOGI(TAG, "WIFI_EVENT_STA_AUTHMODE_CHANGE");
                pEvt = Q_NEW(QEvt, STA_AUTHMODE_CHANGE_SIG);
                QACTIVE_POST(AO_iot_wifi, pEvt, wifi_event_handler);
                break;
            }
            case WIFI_EVENT_STA_WPS_ER_SUCCESS: {
                ESP_LOGI(TAG, "WIFI_EVENT_STA_WPS_ER_SUCCESS");
                // not used in this project
                break;
            }
            case WIFI_EVENT_STA_WPS_ER_FAILED: {
                ESP_LOGI(TAG, "WIFI_EVENT_STA_WPS_ER_FAILED");
                // not used in this project
                break;
            }
            case WIFI_EVENT_STA_WPS_ER_TIMEOUT: {
                ESP_LOGI(TAG, "WIFI_EVENT_STA_WPS_ER_TIMEOUT");
                // not used in this project
                break;
            }
            case WIFI_EVENT_STA_WPS_ER_PIN: {
                ESP_LOGI(TAG, "WIFI_EVENT_STA_WPS_ER_PIN");
                // not used in this project
                break;
            }
            case WIFI_EVENT_STA_WPS_ER_PBC_OVERLAP: {
                ESP_LOGI(TAG, "WIFI_EVENT_STA_WPS_ER_PBC_OVERLAP");
                // not used in this project
                break;
            }
            default:
                break;
        }
    } else if(IP_EVENT == event_base) {
        switch(event_id) {
            case IP_EVENT_STA_GOT_IP: {
                ESP_LOGI(TAG, "IP_EVENT_STA_GOT_IP");
                me->bHasIp = true;
                break;
            }
            default:
                break;
        }
    }

}
/*$enddef${iot::wifi::wifi_event_handler} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${iot::wifi::wifi} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::wifi::wifi} .......................................................*/
/*${iot::wifi::wifi::nvs_read_credential} ..................................*/
static esp_err_t wifi_nvs_read_credential(wifi * const me) {
    char * ssid = NULL;
    char * password = NULL;
    nvs_handle_t my_handle;
    size_t required_size = 0;
    esp_err_t ret = ESP_OK;

    /* Read NVS for ssid and password */
    ret = nvs_open(PROJECT_NVS_NAMESPACE, NVS_READONLY, &my_handle);
    if(ESP_OK == ret) {
        required_size = 0;
        if(ESP_OK == nvs_get_str(my_handle, "wifi_ssid", NULL, &required_size)) {
            if(required_size > 0) {
                ssid = (char *)pvPortMalloc(required_size);
                if(ssid != NULL) {
                    if(ESP_OK == nvs_get_str(my_handle, "wifi_ssid", ssid, &required_size)) {
                        if(me->ssid) {
                            vPortFree(me->ssid);
                            me->ssid = NULL;
                        }
                        me->ssid = ssid;
                    } else {
                        vPortFree(ssid);
                    }
                }
            }
        }

        required_size = 0;
        if(ESP_OK == nvs_get_str(my_handle, "wifi_password", NULL, &required_size)) {
            if(required_size > 0) {
                password = (char *)pvPortMalloc(required_size);
                if(password != NULL) {
                    if(ESP_OK == nvs_get_str(my_handle, "wifi_password", password, &required_size)) {
                        if(me->password) {
                            vPortFree(me->password);
                            me->password = NULL;
                        }
                        me->password = password;
                    } else {
                        vPortFree(password);
                    }
                }
            }
        }

        nvs_close(my_handle);
    }

    return ret;
}

/*${iot::wifi::wifi::nvs_save_credential} ..................................*/
static esp_err_t wifi_nvs_save_credential(wifi * const me, const char * ssid, const char * password) {
    esp_err_t err;
    nvs_handle_t my_handle;
    size_t len;

    if((NULL == ssid) || (NULL == password)) {
        return ESP_ERR_INVALID_ARG;
    }

    // Open
    err = nvs_open(PROJECT_NVS_NAMESPACE, NVS_READWRITE, &my_handle);
    if (ESP_OK != err) {
        return err;
    }

    // Save ssid
    err = nvs_set_str(my_handle, "wifi_ssid", ssid);
    if(ESP_OK != err) {
        goto cleanup_nvs_close;
    }
    if(me->ssid) {
        vPortFree(me->ssid);
        me->ssid = NULL;
    }
    len = strlen(ssid);
    me->ssid = (char *)pvPortMalloc(len+1);
    if(me->ssid) {
        memset(me->ssid, 0, len+1);
        strncpy(me->ssid, ssid, len);
    }

    // Save password
    err = nvs_set_str(my_handle, "wifi_password", password);
    if(ESP_OK != err) {
        goto cleanup_nvs_close;
    }
    if(me->password) {
        vPortFree(me->password);
        me->password = NULL;
    }
    len = strlen(password);
    me->password = (char *)pvPortMalloc(len+1);
    if(me->password) {
        memset(me->password, 0, len+1);
        strncpy(me->password, password, len);
    }

    err = nvs_commit(my_handle);

    cleanup_nvs_close:
        nvs_close(my_handle);
        return err;
}

/*${iot::wifi::wifi::SM} ...................................................*/
static QState wifi_initial(wifi * const me, QEvt const * const e) {
    /*${iot::wifi::wifi::SM::initial} */
    return Q_TRAN(&wifi_TOP);
}
/*${iot::wifi::wifi::SM::TOP} ..............................................*/
static QState wifi_TOP(wifi * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${iot::wifi::wifi::SM::TOP::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&wifi_INITIALIZING);
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::SCAN_START} */
        case SCAN_START_SIG: {
            /*
             * Scan is only valid when wifi is already started (STARTED or CONNECTED)
             */
            if(QEQueue_getNFree(&me->deferQueue) > 0) {
                QActive_defer(&me->super, &me->deferQueue, e);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::STA_DISCONNECTED} */
        case STA_DISCONNECTED_SIG: {
            status_ = Q_TRAN(&wifi_DISCONNECTED);
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::STA_CONNECTED} */
        case STA_CONNECTED_SIG: {
            status_ = Q_TRAN(&wifi_CONNECTED);
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::STA_START} */
        case STA_START_SIG: {
            status_ = Q_TRAN(&wifi_STARTED);
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::STA_STOP} */
        case STA_STOP_SIG: {
            status_ = Q_TRAN(&wifi_STARTING);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${iot::wifi::wifi::SM::TOP::INITIALIZING} ................................*/
static QState wifi_INITIALIZING(wifi * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${iot::wifi::wifi::SM::TOP::INITIALIZING} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "state: INITIALIZING");

            /* Initialize Wifi Stack */
            ESP_ERROR_CHECK(esp_netif_init());
            ESP_ERROR_CHECK(esp_event_loop_create_default());
            me->sta_netif = esp_netif_create_default_wifi_sta();
            Q_ASSERT(me->sta_netif);

            wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
            ESP_ERROR_CHECK(esp_wifi_init(&cfg));

            /* Register event handler */
            ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,
                                ESP_EVENT_ANY_ID, &wifi_event_handler, NULL, NULL));
            ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,
                                IP_EVENT_STA_GOT_IP, &wifi_event_handler, NULL, NULL));

            /* Arm Timer for auto state transit */
            QTimeEvt_armX(&me->tickEvt,
                          pdMS_TO_TICKS(50),
                          pdMS_TO_TICKS(50));
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::INITIALIZING} */
        case Q_EXIT_SIG: {
            /* Disarm Timer */
            QTimeEvt_disarm(&me->tickEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::INITIALIZING::IOT_WIFI_TICK} */
        case IOT_WIFI_TICK_SIG: {
            status_ = Q_TRAN(&wifi_STARTING);
            break;
        }
        default: {
            status_ = Q_SUPER(&wifi_TOP);
            break;
        }
    }
    return status_;
}
/*${iot::wifi::wifi::SM::TOP::STARTED} .....................................*/
static QState wifi_STARTED(wifi * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${iot::wifi::wifi::SM::TOP::STARTED} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "state: STARTED");

            QTimeEvt_armX(&me->tickEvt,
                          pdMS_TO_TICKS(1000),
                          pdMS_TO_TICKS(10000));
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::STARTED} */
        case Q_EXIT_SIG: {
            /* Disarm Timer */
            QTimeEvt_disarm(&me->tickEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::STARTED::IOT_WIFI_TICK} */
        case IOT_WIFI_TICK_SIG: {
            esp_err_t ret = ESP_OK;

            if(me->auto_connect) {
                ESP_LOGI(TAG, "action: connecting");
                ret = esp_wifi_connect();
                if(ESP_OK != ret) {
                    /* Failed connect API.
                       Manually fire event */
                    QEvt * pEvt = Q_NEW(QEvt, STA_DISCONNECTED_SIG);
                    QACTIVE_POST(AO_iot_wifi, pEvt, iot_wifi_connect);
                }
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::STARTED::STA_DISCONNECTED} */
        case STA_DISCONNECTED_SIG: {
            done_cb callback = me->connect_done_cb;
            me->connect_done_cb = NULL;

            if(callback) {
                callback();
            }
            status_ = Q_TRAN(&wifi_DISCONNECTED);
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::STARTED::STA_CONNECTED} */
        case STA_CONNECTED_SIG: {
            done_cb callback = me->connect_done_cb;
            me->connect_done_cb = NULL;

            if(callback) {
                callback();
            }
            status_ = Q_TRAN(&wifi_CONNECTED);
            break;
        }
        default: {
            status_ = Q_SUPER(&wifi_TOP);
            break;
        }
    }
    return status_;
}
/*${iot::wifi::wifi::SM::TOP::CONNECTED} ...................................*/
static QState wifi_CONNECTED(wifi * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${iot::wifi::wifi::SM::TOP::CONNECTED} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "state: CONNECTED");

            QActive_recall((QActive *)me, &me->deferQueue);
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::CONNECTED::SCAN_START} */
        case SCAN_START_SIG: {
            status_ = Q_TRAN(&wifi_SCANNING);
            break;
        }
        default: {
            status_ = Q_SUPER(&wifi_TOP);
            break;
        }
    }
    return status_;
}
/*${iot::wifi::wifi::SM::TOP::SCANNING} ....................................*/
static QState wifi_SCANNING(wifi * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${iot::wifi::wifi::SM::TOP::SCANNING} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "state: SCANNING");

            me->ap_count = 0;
            memset(me->ap_info, 0, sizeof(me->ap_info));

            ESP_ERROR_CHECK(esp_wifi_scan_start(NULL, false)); // Non-blocking

            status_ = Q_HANDLED();
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::SCANNING::SCAN_DONE} */
        case SCAN_DONE_SIG: {
            uint16_t number = IOT_WIFI_SCAN_LIST_SIZE;
            done_cb callback;

            ESP_ERROR_CHECK(esp_wifi_scan_get_ap_records(&number, me->ap_info));
            ESP_ERROR_CHECK(esp_wifi_scan_get_ap_num(&(me->ap_count)));
            ESP_LOGI(TAG, "Total AP scanned: %d", me->ap_count);
            callback = me->scan_done_cb;
            me->scan_done_cb = NULL;

            if(callback) {
                callback();
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::SCANNING::SCAN_START} */
        case SCAN_START_SIG: {
            status_ = Q_TRAN(&wifi_SCANNING);
            break;
        }
        default: {
            status_ = Q_SUPER(&wifi_TOP);
            break;
        }
    }
    return status_;
}
/*${iot::wifi::wifi::SM::TOP::DISCONNECTED} ................................*/
static QState wifi_DISCONNECTED(wifi * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${iot::wifi::wifi::SM::TOP::DISCONNECTED} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "state: DISCONNECTED");

            QActive_recall((QActive *)me, &me->deferQueue);

            QTimeEvt_armX(&me->tickEvt,
                          pdMS_TO_TICKS(10000),
                          pdMS_TO_TICKS(10000));
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::DISCONNECTED} */
        case Q_EXIT_SIG: {
            /* Disarm Timer */
            QTimeEvt_disarm(&me->tickEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::DISCONNECTED::STA_STOP, IOT_WIFI_TICK} */
        case STA_STOP_SIG: /* intentionally fall through */
        case IOT_WIFI_TICK_SIG: {
            ESP_LOGI(TAG, "action: stopping wifi");
            esp_wifi_stop();
            status_ = Q_TRAN(&wifi_STARTING);
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::DISCONNECTED::SCAN_START} */
        case SCAN_START_SIG: {
            status_ = Q_TRAN(&wifi_SCANNING);
            break;
        }
        default: {
            status_ = Q_SUPER(&wifi_TOP);
            break;
        }
    }
    return status_;
}
/*${iot::wifi::wifi::SM::TOP::STARTING} ....................................*/
static QState wifi_STARTING(wifi * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${iot::wifi::wifi::SM::TOP::STARTING} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "state: STARTING");

            /* Arm Timer for start retry interval: 10s */
            QTimeEvt_armX(&me->tickEvt,
                          pdMS_TO_TICKS(1000),
                          pdMS_TO_TICKS(10000));
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::STARTING} */
        case Q_EXIT_SIG: {
            /* Disarm Timer */
            QTimeEvt_disarm(&me->tickEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::STARTING::IOT_WIFI_TICK} */
        case IOT_WIFI_TICK_SIG: {
            /* Read Wifi Credential from NVS */
            wifi_nvs_read_credential(me);
            if(me->ssid != NULL) {
                strcpy((char *)me->wifi_config.sta.ssid, me->ssid);
            }
            if(me->password != NULL) {
                strcpy((char *)me->wifi_config.sta.password, me->password);
            }

            /* Setting a password implies station will connect to all security modes including WEP/WPA.
             * However these modes are deprecated and not advisable to be used. Incase your Access point
             * doesn't support WPA2, these mode can be enabled by commenting below line */
            me->wifi_config.sta.threshold.authmode = WIFI_AUTH_WPA2_PSK;
            me->wifi_config.sta.pmf_cfg.capable = true;
            me->wifi_config.sta.pmf_cfg.required = false;

            ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
            ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &me->wifi_config));
            ESP_ERROR_CHECK(esp_wifi_start());
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::wifi::wifi::SM::TOP::STARTING::STA_START} */
        case STA_START_SIG: {
            status_ = Q_TRAN(&wifi_STARTED);
            break;
        }
        default: {
            status_ = Q_SUPER(&wifi_TOP);
            break;
        }
    }
    return status_;
}
/*$enddef${iot::wifi::wifi} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
