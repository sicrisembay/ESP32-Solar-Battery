/*$file${iot::mqtt_client::.::iot_mqtt_client.c} vvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: esp32_main.qm
* File:  ${iot::mqtt_client::.::iot_mqtt_client.c}
*
* This code has been generated by QM 4.5.0 (https://www.state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${iot::mqtt_client::.::iot_mqtt_client.c} ^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <string.h>
#include "freertos/queue.h"
#include "esp_system.h"
#include "esp_event.h"
#include "esp_wifi.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "nvs.h"

#include "aws_iot_config.h"
#include "aws_iot_log.h"
#include "aws_iot_version.h"
#include "aws_iot_mqtt_client_interface.h"

#include "qpc.h"
#if defined(CONFIG_QPC_QSPY_ENABLE)
#include "qs.h"
#endif /* #if defined(CONFIG_QPC_QSPY_ENABLE) */

#include "priorityList.h"
#include "signalList.h"
#include "project_def.h"

#include "iot_mqtt_client.h"
#include "iot_wifi.h"
#include "cert_default/default_host.h"

Q_DEFINE_THIS_MODULE("iot_mqtt_client")

static const char * TAG = "iot_mqtt_client";

enum mqttSignal {
    IOT_MQTT_TICK_SIG = MAX_SIG,
};

static const char * HOSTADDRESS_DEFAULT = DEFAULT_HOST_ADDRESS;  // defined in cert_default/default_host.h
extern const char default_ca_start[] asm("_binary_default_ca_pem_start");
extern const char default_ca_end[] asm("_binary_default_ca_pem_end");
extern const char default_crt_start[] asm("_binary_default_crt_start");
extern const char default_crt_end[] asm("_binary_default_crt_end");
extern const char default_key_start[] asm("_binary_default_key_start");
extern const char default_key_end[] asm("_binary_default_key_end");

/*$declare${iot::mqtt_client::mqtt_client} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::mqtt_client::mqtt_client} .........................................*/
typedef struct {
/* protected: */
    QActive super;

/* private: */
    QTimeEvt tickEvt;
    char * hostAddress;
    uint16_t port;
    AWS_IoT_Client client;
    IoT_Client_Init_Params mqttInitParams;
    IoT_Client_Connect_Params connectParams;
    IoT_Publish_Message_Params paramsQOS0;
    IoT_Publish_Message_Params paramsQOS1;
    char * root_ca;
    char * client_cert;
    char * client_key;

    /*
     * Client Unique name
     * Format: "Dispenser000000000000"
     * Suffix is derived from MAC address
     */
    char clientName[24];
} mqtt_client;

/* private: */
static esp_err_t mqtt_client_nvs_read(mqtt_client * const me);
static esp_err_t mqtt_client_nvs_save_host_address(mqtt_client * const me);
static esp_err_t mqtt_client_nvs_save_root_ca(mqtt_client * const me);
static esp_err_t mqtt_client_nvs_save_cert(mqtt_client * const me);
static esp_err_t mqtt_client_nvs_save_key(mqtt_client * const me);

/* protected: */
static QState mqtt_client_initial(mqtt_client * const me, QEvt const * const e);
static QState mqtt_client_TOP(mqtt_client * const me, QEvt const * const e);
static QState mqtt_client_INITIALIZING(mqtt_client * const me, QEvt const * const e);
static QState mqtt_client_INITIALIZED(mqtt_client * const me, QEvt const * const e);
static QState mqtt_client_CONNECTING(mqtt_client * const me, QEvt const * const e);
static QState mqtt_client_CONNECTED(mqtt_client * const me, QEvt const * const e);
/*$enddecl${iot::mqtt_client::mqtt_client} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

static mqtt_client l_mqtt_client;
static QEvt const * l_mqttClientQSto[64];
/* FreeRTOS stack for AO */
static StackType_t mqttClientStack[8196];

/*$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 650U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.5.0 or higher required
#endif
/*$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${iot::mqtt_client::AO_iot_mqtt_client}} vvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::mqtt_client::AO_iot_mqtt_client} ..................................*/
QActive * const AO_iot_mqtt_client = &(l_mqtt_client.super);
/*$enddef${iot::mqtt_client::AO_iot_mqtt_client}} ^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${iot::mqtt_client::iot_mqtt_client_ctor} vvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::mqtt_client::iot_mqtt_client_ctor} ................................*/
void iot_mqtt_client_ctor(void) {
    mqtt_client * me;
    static uint32_t bInitOnce = 0;

    if(bInitOnce == 0) {
        me = &l_mqtt_client;

        me->hostAddress = NULL;
        me->port = 8883;
        me->mqttInitParams = iotClientInitParamsDefault;
        me->connectParams = iotClientConnectParamsDefault;

        /* Call constructor */
        QActive_ctor(&me->super, Q_STATE_CAST(&mqtt_client_initial));
        /* Call Timer Constructor */
        QTimeEvt_ctorX(&me->tickEvt, &me->super, IOT_MQTT_TICK_SIG, 0U);

        /* Create AO Task */
        QActive_setAttr(AO_iot_mqtt_client, TASK_NAME_ATTR, "iot_mqtt");
        bInitOnce = 1;
        QACTIVE_START(
                AO_iot_mqtt_client,             /* AO to start */
                AO_PRIORITY_MQTT_CLIENT,        /* QP priority of the AO */
                l_mqttClientQSto,               /* Event Queue Storage */
                Q_DIM(l_mqttClientQSto),        /* Lenght of Event Queue */
                mqttClientStack,                /* Stack storage */
                sizeof(mqttClientStack),        /* Size of Stack */
                (QEvt *)0                       /* Not Used */
                );
    }

}
/*$enddef${iot::mqtt_client::iot_mqtt_client_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${iot::mqtt_client::iot_mqtt_publish} vvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::mqtt_client::iot_mqtt_publish} ....................................*/
void iot_mqtt_publish(
    const char * topic,
    uint16_t topic_len,
    IoT_Publish_Message_Params * pubParam)
{
    mqtt_client * me = &l_mqtt_client;

    aws_iot_mqtt_publish(&(me->client), topic, topic_len, pubParam);
}
/*$enddef${iot::mqtt_client::iot_mqtt_publish} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${iot::mqtt_client::disconnect_handler} vvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::mqtt_client::disconnect_handler} ..................................*/
static void disconnect_handler(AWS_IoT_Client * pClient, void * data) {
}
/*$enddef${iot::mqtt_client::disconnect_handler} ^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${iot::mqtt_client::mqtt_client} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${iot::mqtt_client::mqtt_client} .........................................*/
/*${iot::mqtt_client::mqtt_client::nvs_read} ...............................*/
static esp_err_t mqtt_client_nvs_read(mqtt_client * const me) {
    char * hostAddress = NULL;
    char * root_ca = NULL;
    char * client_cert = NULL;
    char * client_key = NULL;

    nvs_handle_t my_handle;
    size_t required_size = 0;
    esp_err_t ret = ESP_OK;

    /* Read NVS for mqtt host address */
    ret = nvs_open(PROJECT_NVS_NAMESPACE, NVS_READWRITE, &my_handle);
    if(ESP_OK == ret) {
        required_size = 0;
        if(ESP_OK == nvs_get_str(my_handle, "mqtt_host_addr", NULL, &required_size)) {
            if(required_size > 0) {
                hostAddress = (char *)pvPortMalloc(required_size);
                if(hostAddress != NULL) {
                    if(ESP_OK == nvs_get_str(my_handle, "mqtt_host_addr", hostAddress, &required_size)) {
                        if(me->hostAddress) {
                            vPortFree(me->hostAddress);
                            me->hostAddress = NULL;
                        }
                        me->hostAddress = hostAddress;
                    } else {
                        vPortFree(hostAddress);
                    }
                }
            }
        }

        required_size = 0;
        if(ESP_OK == nvs_get_str(my_handle, "mqtt_ca", NULL, &required_size)) {
            if(required_size > 0) {
                root_ca = (char *)pvPortMalloc(required_size);
                if(root_ca != NULL) {
                    if(ESP_OK == nvs_get_str(my_handle, "mqtt_ca", root_ca, &required_size)) {
                        if(me->root_ca) {
                            vPortFree(me->root_ca);
                            me->root_ca = NULL;
                        }
                        me->root_ca = root_ca;
                    } else {
                        vPortFree(root_ca);
                    }
                }
            }
        }

        required_size = 0;
        if(ESP_OK == nvs_get_str(my_handle, "mqtt_crt", NULL, &required_size)) {
            if(required_size > 0) {
                client_cert = (char *)pvPortMalloc(required_size);
                if(client_cert != NULL) {
                    if(ESP_OK == nvs_get_str(my_handle, "mqtt_crt", client_cert, &required_size)) {
                        if(me->client_cert) {
                            vPortFree(me->client_cert);
                            me->client_cert = NULL;
                        }
                        me->client_cert = client_cert;
                    } else {
                        vPortFree(client_cert);
                    }
                }
            }
        }

        required_size = 0;
        if(ESP_OK == nvs_get_str(my_handle, "mqtt_key", NULL, &required_size)) {
            if(required_size > 0) {
                client_key = (char *)pvPortMalloc(required_size);
                if(client_key != NULL) {
                    if(ESP_OK == nvs_get_str(my_handle, "mqtt_key", client_key, &required_size)) {
                        if(me->client_key) {
                            vPortFree(me->client_key);
                            me->client_key = NULL;
                        }
                        me->client_key = client_key;
                    } else {
                        vPortFree(client_key);
                    }
                }
            }
        }

        nvs_close(my_handle);
    }

    return ret;
}

/*${iot::mqtt_client::mqtt_client::nvs_save_host_address} ..................*/
static esp_err_t mqtt_client_nvs_save_host_address(mqtt_client * const me) {
    esp_err_t ret;
    nvs_handle_t my_handle;

    // Open
    ret = nvs_open(PROJECT_NVS_NAMESPACE, NVS_READWRITE, &my_handle);
    if (ESP_OK != ret) {
        return ret;
    }

    // Save hostAddress
    ret = nvs_set_str(my_handle, "mqtt_host_addr", me->hostAddress);
    if(ESP_OK != ret) {
        goto cleanup_nvs_close;
    }

    ret = nvs_commit(my_handle);

    cleanup_nvs_close:
        nvs_close(my_handle);
        return ret;
}

/*${iot::mqtt_client::mqtt_client::nvs_save_root_ca} .......................*/
static esp_err_t mqtt_client_nvs_save_root_ca(mqtt_client * const me) {
    esp_err_t ret;
    nvs_handle_t my_handle;

    // Open
    ret = nvs_open(PROJECT_NVS_NAMESPACE, NVS_READWRITE, &my_handle);
    if (ESP_OK != ret) {
        return ret;
    }

    // Save rootCA
    ret = nvs_set_str(my_handle, "mqtt_ca", me->root_ca);
    if(ESP_OK != ret) {
        goto cleanup_nvs_close;
    }

    ret = nvs_commit(my_handle);

    cleanup_nvs_close:
        nvs_close(my_handle);
        return ret;
}

/*${iot::mqtt_client::mqtt_client::nvs_save_cert} ..........................*/
static esp_err_t mqtt_client_nvs_save_cert(mqtt_client * const me) {
    esp_err_t ret;
    nvs_handle_t my_handle;

    // Open
    ret = nvs_open(PROJECT_NVS_NAMESPACE, NVS_READWRITE, &my_handle);
    if (ESP_OK != ret) {
        return ret;
    }

    // Save Client Cert
    ret = nvs_set_str(my_handle, "mqtt_crt", me->client_cert);
    if(ESP_OK != ret) {
        goto cleanup_nvs_close;
    }

    ret = nvs_commit(my_handle);

    cleanup_nvs_close:
        nvs_close(my_handle);
        return ret;
}

/*${iot::mqtt_client::mqtt_client::nvs_save_key} ...........................*/
static esp_err_t mqtt_client_nvs_save_key(mqtt_client * const me) {
    esp_err_t ret;
    nvs_handle_t my_handle;

    // Open
    ret = nvs_open(PROJECT_NVS_NAMESPACE, NVS_READWRITE, &my_handle);
    if (ESP_OK != ret) {
        return ret;
    }

    // Save Client Private Key
    ret = nvs_set_str(my_handle, "mqtt_key", me->client_key);
    if(ESP_OK != ret) {
        goto cleanup_nvs_close;
    }

    ret = nvs_commit(my_handle);

    cleanup_nvs_close:
        nvs_close(my_handle);
        return ret;
}

/*${iot::mqtt_client::mqtt_client::SM} .....................................*/
static QState mqtt_client_initial(mqtt_client * const me, QEvt const * const e) {
    /*${iot::mqtt_client::mqtt_client::SM::initial} */
    return Q_TRAN(&mqtt_client_TOP);
}
/*${iot::mqtt_client::mqtt_client::SM::TOP} ................................*/
static QState mqtt_client_TOP(mqtt_client * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${iot::mqtt_client::mqtt_client::SM::TOP::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&mqtt_client_INITIALIZING);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${iot::mqtt_client::mqtt_client::SM::TOP::INITIALIZING} ..................*/
static QState mqtt_client_INITIALIZING(mqtt_client * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${iot::mqtt_client::mqtt_client::SM::TOP::INITIALIZING} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "state: INITIALIZING");
            IoT_Error_t ret;

            /* Read NVS */
            ESP_ERROR_CHECK(mqtt_client_nvs_read(me));

            /* Check Host Address */
            if(me->hostAddress != NULL) {
                ESP_LOGI(TAG, "host address: %s", me->hostAddress);
            } else {
                ESP_LOGI(TAG, "Set host address to Default");
                me->hostAddress = (char *)pvPortMalloc(strlen(HOSTADDRESS_DEFAULT) + 1);
                if(me->hostAddress) {
                    memset(me->hostAddress, 0, strlen(HOSTADDRESS_DEFAULT) + 1);
                    strcpy(me->hostAddress, HOSTADDRESS_DEFAULT);
                    mqtt_client_nvs_save_host_address(me);
                }
            }

            /* Check Root CA */
            if(me->root_ca != NULL) {
                ESP_LOGI(TAG, "Root CA found");
            } else {
                ESP_LOGI(TAG, "Set RootCA to Default (size: %d)", strlen(default_ca_start));
                me->root_ca = default_ca_start;
                mqtt_client_nvs_save_root_ca(me);
            }

            /* Check Client Cert */
            if(me->client_cert != NULL) {
                ESP_LOGI(TAG, "Client Cert found");
            } else {
                ESP_LOGI(TAG, "Set Client cert to Default (size: %d)", strlen(default_crt_start));
                me->client_cert = default_crt_start;
                mqtt_client_nvs_save_cert(me);
            }

            /* Check Client Key */
            if(me->client_key != NULL) {
                ESP_LOGI(TAG, "Client Key found");
            } else {
                ESP_LOGI(TAG, "Set Client key to Default (size: %d)", strlen(default_key_start));
                me->client_key = default_key_start;
                mqtt_client_nvs_save_key(me);
            }

            ESP_LOGI(TAG, "AWS IoT SDK Version %d.%d.%d-%s", VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH, VERSION_TAG);

            me->mqttInitParams.enableAutoReconnect = false; // We enable this later below
            me->mqttInitParams.pHostURL = me->hostAddress;
            me->mqttInitParams.port = me->port;
            me->mqttInitParams.pRootCALocation = me->root_ca;
            me->mqttInitParams.pDeviceCertLocation = me->client_cert;
            me->mqttInitParams.pDevicePrivateKeyLocation = me->client_key;
            me->mqttInitParams.mqttCommandTimeout_ms = 20000;
            me->mqttInitParams.tlsHandshakeTimeout_ms = 5000;
            me->mqttInitParams.isSSLHostnameVerify = true;
            me->mqttInitParams.disconnectHandler = disconnect_handler;
            me->mqttInitParams.disconnectHandlerData = NULL;

            ret = aws_iot_mqtt_init(&(me->client), &(me->mqttInitParams));
            if(ret != SUCCESS) {
                ESP_LOGE(TAG, "mqtt client init failed (%d)", ret);
            }

            /* Arm Timer for auto state transit */
            QTimeEvt_armX(&me->tickEvt,
                          pdMS_TO_TICKS(50),
                          pdMS_TO_TICKS(50));
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::mqtt_client::mqtt_client::SM::TOP::INITIALIZING} */
        case Q_EXIT_SIG: {
            /* Disarm Timer */
            QTimeEvt_disarm(&me->tickEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::mqtt_client::mqtt_client::SM::TOP::INITIALIZING::IOT_MQTT_TICK} */
        case IOT_MQTT_TICK_SIG: {
            status_ = Q_TRAN(&mqtt_client_INITIALIZED);
            break;
        }
        default: {
            status_ = Q_SUPER(&mqtt_client_TOP);
            break;
        }
    }
    return status_;
}
/*${iot::mqtt_client::mqtt_client::SM::TOP::INITIALIZED} ...................*/
static QState mqtt_client_INITIALIZED(mqtt_client * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${iot::mqtt_client::mqtt_client::SM::TOP::INITIALIZED} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "state: INITIALIZED");

            /* Arm Timer for state transit */
            QTimeEvt_armX(&me->tickEvt,
                          pdMS_TO_TICKS(1000),
                          pdMS_TO_TICKS(1000));
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::mqtt_client::mqtt_client::SM::TOP::INITIALIZED} */
        case Q_EXIT_SIG: {
            /* Disarm Timer */
            QTimeEvt_disarm(&me->tickEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::mqtt_client::mqtt_client::SM::TOP::INITIALIZED::IOT_MQTT_TICK} */
        case IOT_MQTT_TICK_SIG: {
            /*${iot::mqtt_client::mqtt_client::SM::TOP::INITIALIZED::IOT_MQTT_TICK::[wifi_has_ip]} */
            if (iot_wifi_has_ip()) {
                status_ = Q_TRAN(&mqtt_client_CONNECTING);
            }
            /*${iot::mqtt_client::mqtt_client::SM::TOP::INITIALIZED::IOT_MQTT_TICK::[else]} */
            else {
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&mqtt_client_TOP);
            break;
        }
    }
    return status_;
}
/*${iot::mqtt_client::mqtt_client::SM::TOP::CONNECTING} ....................*/
static QState mqtt_client_CONNECTING(mqtt_client * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${iot::mqtt_client::mqtt_client::SM::TOP::CONNECTING} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "state: CONNECTING");

            me->connectParams.keepAliveIntervalInSec = 30;
            me->connectParams.isCleanSession = true;
            me->connectParams.MQTTVersion = MQTT_3_1_1;

            /* Generate Unique Client name */
            uint8_t mac[6];
            esp_wifi_get_mac(ESP_IF_WIFI_STA, mac);
            memset(me->clientName, 0, sizeof(me->clientName));
            snprintf(me->clientName, sizeof(me->clientName)-1, "device%02X%02X%02X%02X%02X%02X",
                mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);

            ESP_LOGI(TAG, "client name: %s", me->clientName);
            me->connectParams.pClientID = me->clientName;
            me->connectParams.clientIDLen = (uint16_t) strlen(me->clientName);
            me->connectParams.isWillMsgPresent = false;

            /* Arm Timer for state transit */
            QTimeEvt_armX(&me->tickEvt,
                          pdMS_TO_TICKS(500),
                          pdMS_TO_TICKS(10000));
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::mqtt_client::mqtt_client::SM::TOP::CONNECTING} */
        case Q_EXIT_SIG: {
            /* Disarm Timer */
            QTimeEvt_disarm(&me->tickEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${iot::mqtt_client::mqtt_client::SM::TOP::CONNECTING::IOT_MQTT_TICK} */
        case IOT_MQTT_TICK_SIG: {
            IoT_Error_t ret = aws_iot_mqtt_connect(&(me->client),
                                    &(me->connectParams));
            /*${iot::mqtt_client::mqtt_client::SM::TOP::CONNECTING::IOT_MQTT_TICK::[success]} */
            if (SUCCESS == ret) {
                status_ = Q_TRAN(&mqtt_client_CONNECTED);
            }
            /*${iot::mqtt_client::mqtt_client::SM::TOP::CONNECTING::IOT_MQTT_TICK::[else]} */
            else {
                ESP_LOGE(TAG, "Error(%d) connecting to %s:%d", ret,
                            me->mqttInitParams.pHostURL,
                            me->mqttInitParams.port);
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&mqtt_client_TOP);
            break;
        }
    }
    return status_;
}
/*${iot::mqtt_client::mqtt_client::SM::TOP::CONNECTED} .....................*/
static QState mqtt_client_CONNECTED(mqtt_client * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${iot::mqtt_client::mqtt_client::SM::TOP::CONNECTED} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "state: CONNECTED");

            IoT_Error_t ret = aws_iot_mqtt_autoreconnect_set_status(&(me->client), true);
            if(SUCCESS != ret) {
                ESP_LOGE(TAG, "Unable to set Auto Reconnect to true - %d", ret);
                /// TODO
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&mqtt_client_TOP);
            break;
        }
    }
    return status_;
}
/*$enddef${iot::mqtt_client::mqtt_client} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
